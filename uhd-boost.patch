--- UHD_3.10.1.1_release/include/uhd/utils/byteswap.ipp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/include/uhd/utils/byteswap.ipp	2020-07-08 05:40:29.600351207 +0200
@@ -99,12 +99,12 @@
 /***********************************************************************
  * Define the templated network to/from host conversions
  **********************************************************************/
-#include <boost/detail/endian.hpp>
+#include <boost/predef/other/endian.h>
 
 namespace uhd {
 
 template<typename T> UHD_INLINE T ntohx(T num){
-    #ifdef BOOST_BIG_ENDIAN
+    #if BOOST_ENDIAN_BIG_BYTE
         return num;
     #else
         return uhd::byteswap(num);
@@ -112,7 +112,7 @@
 }
 
 template<typename T> UHD_INLINE T htonx(T num){
-    #ifdef BOOST_BIG_ENDIAN
+    #if BOOST_ENDIAN_BIG_BYTE
         return num;
     #else
         return uhd::byteswap(num);
@@ -120,7 +120,7 @@
 }
 
 template<typename T> UHD_INLINE T wtohx(T num){
-    #ifdef BOOST_BIG_ENDIAN
+    #if BOOST_ENDIAN_BIG_BYTE
         return uhd::byteswap(num);
     #else
         return num;
@@ -128,7 +128,7 @@
 }
 
 template<typename T> UHD_INLINE T htowx(T num){
-    #ifdef BOOST_BIG_ENDIAN
+    #if BOOST_ENDIAN_BIG_BYTE
         return uhd::byteswap(num);
     #else
         return num;
--- UHD_3.10.1.1_release/lib/rfnoc/ddc_block_ctrl_impl.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/rfnoc/ddc_block_ctrl_impl.cpp	2020-07-08 19:19:33.150784423 +0200
@@ -53,43 +53,43 @@
         for (size_t chan = 0; chan < get_input_ports().size(); chan++) {
             double default_freq = get_arg<double>("freq", chan);
             _tree->access<double>(get_arg_path("freq/value", chan))
-                .set_coercer(boost::bind(&ddc_block_ctrl_impl::set_freq, this, _1, chan))
+                .set_coercer(boost::bind(&ddc_block_ctrl_impl::set_freq, this, boost::placeholders::_1, chan))
                 .set(default_freq);
             ;
             double default_output_rate = get_arg<double>("output_rate", chan);
             _tree->access<double>(get_arg_path("output_rate/value", chan))
-                .set_coercer(boost::bind(&ddc_block_ctrl_impl::set_output_rate, this, _1, chan))
+                .set_coercer(boost::bind(&ddc_block_ctrl_impl::set_output_rate, this, boost::placeholders::_1, chan))
                 .set(default_output_rate)
             ;
             _tree->access<double>(get_arg_path("input_rate/value", chan))
-                .add_coerced_subscriber(boost::bind(&ddc_block_ctrl_impl::set_input_rate, this, _1, chan))
+                .add_coerced_subscriber(boost::bind(&ddc_block_ctrl_impl::set_input_rate, this, boost::placeholders::_1, chan))
             ;
 
             // Legacy properties (for backward compat w/ multi_usrp)
             const uhd::fs_path dsp_base_path = _root_path / "legacy_api" / chan;
             // Legacy properties
             _tree->create<double>(dsp_base_path / "rate/value")
-                .set_coercer(boost::bind(&lambda_forward_prop, _tree, get_arg_path("output_rate/value", chan), _1))
+                .set_coercer(boost::bind(&lambda_forward_prop, _tree, get_arg_path("output_rate/value", chan), boost::placeholders::_1))
                 .set_publisher(boost::bind(&lambda_forward_prop, _tree, get_arg_path("output_rate/value", chan)))
             ;
             _tree->create<uhd::meta_range_t>(dsp_base_path / "rate/range")
                 .set_publisher(boost::bind(&ddc_block_ctrl_impl::get_output_rates, this))
             ;
             _tree->create<double>(dsp_base_path / "freq/value")
-                .set_coercer(boost::bind(&lambda_forward_prop, _tree, get_arg_path("freq/value", chan), _1))
+                .set_coercer(boost::bind(&lambda_forward_prop, _tree, get_arg_path("freq/value", chan), boost::placeholders::_1))
                 .set_publisher(boost::bind(&lambda_forward_prop, _tree, get_arg_path("freq/value", chan)))
             ;
             _tree->create<uhd::meta_range_t>(dsp_base_path / "freq/range")
                 .set_publisher(boost::bind(&ddc_block_ctrl_impl::get_freq_range, this))
             ;
             _tree->access<uhd::time_spec_t>("time/cmd")
-                .add_coerced_subscriber(boost::bind(&block_ctrl_base::set_command_time, this, _1, chan))
+                .add_coerced_subscriber(boost::bind(&block_ctrl_base::set_command_time, this, boost::placeholders::_1, chan))
             ;
             if (_tree->exists("tick_rate")) {
                 const double tick_rate = _tree->access<double>("tick_rate").get();
                 set_command_tick_rate(tick_rate, chan);
                 _tree->access<double>("tick_rate")
-                    .add_coerced_subscriber(boost::bind(&block_ctrl_base::set_command_tick_rate, this, _1, chan))
+                    .add_coerced_subscriber(boost::bind(&block_ctrl_base::set_command_tick_rate, this, boost::placeholders::_1, chan))
                 ;
             }
 
--- UHD_3.10.1.1_release/lib/rfnoc/duc_block_ctrl_impl.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/rfnoc/duc_block_ctrl_impl.cpp	2020-07-08 20:26:53.098898147 +0200
@@ -53,43 +53,43 @@
         for (size_t chan = 0; chan < get_input_ports().size(); chan++) {
             double default_freq = get_arg<double>("freq", chan);
             _tree->access<double>(get_arg_path("freq/value", chan))
-                .set_coercer(boost::bind(&duc_block_ctrl_impl::set_freq, this, _1, chan))
+                .set_coercer(boost::bind(&duc_block_ctrl_impl::set_freq, this, boost::placeholders::_1, chan))
                 .set(default_freq);
             ;
             double default_input_rate = get_arg<double>("input_rate", chan);
             _tree->access<double>(get_arg_path("input_rate/value", chan))
-                .set_coercer(boost::bind(&duc_block_ctrl_impl::set_input_rate, this, _1, chan))
+                .set_coercer(boost::bind(&duc_block_ctrl_impl::set_input_rate, this, boost::placeholders::_1, chan))
                 .set(default_input_rate)
             ;
             _tree->access<double>(get_arg_path("output_rate/value", chan))
-                .add_coerced_subscriber(boost::bind(&duc_block_ctrl_impl::set_output_rate, this, _1, chan))
+                .add_coerced_subscriber(boost::bind(&duc_block_ctrl_impl::set_output_rate, this, boost::placeholders::_1, chan))
             ;
 
             // Legacy properties (for backward compat w/ multi_usrp)
             const uhd::fs_path dsp_base_path = _root_path / "legacy_api" / chan;
             // Legacy properties
             _tree->create<double>(dsp_base_path / "rate/value")
-                .set_coercer(boost::bind(&lambda_forward_prop, _tree, get_arg_path("input_rate/value", chan), _1))
+                .set_coercer(boost::bind(&lambda_forward_prop, _tree, get_arg_path("input_rate/value", chan), boost::placeholders::_1))
                 .set_publisher(boost::bind(&lambda_forward_prop, _tree, get_arg_path("input_rate/value", chan)))
             ;
             _tree->create<uhd::meta_range_t>(dsp_base_path / "rate/range")
                 .set_publisher(boost::bind(&duc_block_ctrl_impl::get_input_rates, this))
             ;
             _tree->create<double>(dsp_base_path / "freq/value")
-                .set_coercer(boost::bind(&lambda_forward_prop, _tree, get_arg_path("freq/value", chan), _1))
+                .set_coercer(boost::bind(&lambda_forward_prop, _tree, get_arg_path("freq/value", chan), boost::placeholders::_1))
                 .set_publisher(boost::bind(&lambda_forward_prop, _tree, get_arg_path("freq/value", chan)))
             ;
             _tree->create<uhd::meta_range_t>(dsp_base_path / "freq/range")
                 .set_publisher(boost::bind(&duc_block_ctrl_impl::get_freq_range, this))
             ;
             _tree->access<uhd::time_spec_t>("time/cmd")
-                .add_coerced_subscriber(boost::bind(&block_ctrl_base::set_command_time, this, _1, chan))
+                .add_coerced_subscriber(boost::bind(&block_ctrl_base::set_command_time, this, boost::placeholders::_1, chan))
             ;
             if (_tree->exists("tick_rate")) {
                 const double tick_rate = _tree->access<double>("tick_rate").get();
                 set_command_tick_rate(tick_rate, chan);
                 _tree->access<double>("tick_rate")
-                    .add_coerced_subscriber(boost::bind(&block_ctrl_base::set_command_tick_rate, this, _1, chan))
+                    .add_coerced_subscriber(boost::bind(&block_ctrl_base::set_command_tick_rate, this, boost::placeholders::_1, chan))
                 ;
             }
 
--- UHD_3.10.1.1_release/lib/rfnoc/dma_fifo_block_ctrl_impl.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/rfnoc/dma_fifo_block_ctrl_impl.cpp	2020-07-08 21:00:50.884525182 +0200
@@ -43,19 +43,19 @@
                 // poke32 functor
                 boost::bind(
                     static_cast< void (block_ctrl_base::*)(const uint32_t, const uint32_t, const size_t) >(&block_ctrl_base::sr_write),
-                    this, _1, _2, i
+                    this, boost::placeholders::_1, boost::placeholders::_2, i
                 ),
                 // peek32 functor
                 boost::bind(
                     static_cast< uint32_t (block_ctrl_base::*)(const uint32_t, const size_t) >(&block_ctrl_base::user_reg_read32),
                     this,
-                    _1, i
+                    boost::placeholders::_1, i
                 ),
                 // peek64 functor
                 boost::bind(
                     static_cast< uint64_t (block_ctrl_base::*)(const uint32_t, const size_t) >(&block_ctrl_base::user_reg_read64),
                     this,
-                    _1, i
+                    boost::placeholders::_1, i
                 )
             );
             static const uint32_t USER_SR_BASE = 128*4;
@@ -81,11 +81,11 @@
                 }
             }
             _tree->access<int>(get_arg_path("base_addr/value", i))
-                .add_coerced_subscriber(boost::bind(&dma_fifo_block_ctrl_impl::resize, this, _1, boost::ref(_perifs[i].depth), i))
+                .add_coerced_subscriber(boost::bind(&dma_fifo_block_ctrl_impl::resize, this, boost::placeholders::_1, boost::ref(_perifs[i].depth), i))
                 .set(_perifs[i].base_addr)
             ;
             _tree->access<int>(get_arg_path("depth/value", i))
-                .add_coerced_subscriber(boost::bind(&dma_fifo_block_ctrl_impl::resize, this, boost::ref(_perifs[i].base_addr), _1, i))
+                .add_coerced_subscriber(boost::bind(&dma_fifo_block_ctrl_impl::resize, this, boost::ref(_perifs[i].base_addr), boost::placeholders::_1, i))
                 .set(_perifs[i].depth)
             ;
         }
--- UHD_3.10.1.1_release/lib/usrp/multi_usrp.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/usrp/multi_usrp.cpp	2020-07-08 21:03:33.130312888 +0200
@@ -221,7 +221,7 @@
     gain_fcns_t gain_fcns;
     gain_fcns.get_range = boost::bind(&get_gain_range, subtree);
     gain_fcns.get_value = boost::bind(&get_gain_value, subtree);
-    gain_fcns.set_value = boost::bind(&set_gain_value, subtree, _1);
+    gain_fcns.set_value = boost::bind(&set_gain_value, subtree, boost::placeholders::_1);
     return gain_fcns;
 }
 
--- UHD_3.10.1.1_release/lib/usrp/cores/rx_vita_core_3000.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/usrp/cores/rx_vita_core_3000.cpp	2020-07-08 21:23:54.500362825 +0200
@@ -74,7 +74,7 @@
         // At 1 ms * 200 MHz = 200k cycles, 8 bytes * 200k cycles = 1.6 MB
         // of flushed data, when the typical amount of data buffered
         // is on the order of kilobytes
-        boost::this_thread::sleep(boost::posix_time::milliseconds(1.0));
+        boost::this_thread::sleep(boost::posix_time::milliseconds(1));
 
         _iface->poke32(REG_FC_WINDOW, window_size-1);
         _iface->poke32(REG_FC_ENABLE, window_size?1:0);
--- UHD_3.10.1.1_release/lib/usrp/cores/rx_dsp_core_3000.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/usrp/cores/rx_dsp_core_3000.cpp	2020-07-08 22:08:18.879261980 +0200
@@ -284,11 +284,11 @@
         ;
         subtree->create<double>("rate/value")
             .set(DEFAULT_RATE)
-            .set_coercer(boost::bind(&rx_dsp_core_3000::set_host_rate, this, _1))
+            .set_coercer(boost::bind(&rx_dsp_core_3000::set_host_rate, this, boost::placeholders::_1))
         ;
         subtree->create<double>("freq/value")
             .set(DEFAULT_CORDIC_FREQ)
-            .set_coercer(boost::bind(&rx_dsp_core_3000::set_freq, this, _1))
+            .set_coercer(boost::bind(&rx_dsp_core_3000::set_freq, this, boost::placeholders::_1))
         ;
         subtree->create<meta_range_t>("freq/range")
             .set_publisher(boost::bind(&rx_dsp_core_3000::get_freq_range, this))
--- UHD_3.10.1.1_release/lib/usrp/cores/tx_dsp_core_3000.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/usrp/cores/tx_dsp_core_3000.cpp	2020-07-08 22:08:52.442413486 +0200
@@ -184,11 +184,11 @@
         ;
         subtree->create<double>("rate/value")
             .set(DEFAULT_RATE)
-            .set_coercer(boost::bind(&tx_dsp_core_3000::set_host_rate, this, _1))
+            .set_coercer(boost::bind(&tx_dsp_core_3000::set_host_rate, this, boost::placeholders::_1))
         ;
         subtree->create<double>("freq/value")
             .set(DEFAULT_CORDIC_FREQ)
-            .set_coercer(boost::bind(&tx_dsp_core_3000::set_freq, this, _1))
+            .set_coercer(boost::bind(&tx_dsp_core_3000::set_freq, this, boost::placeholders::_1))
         ;
         subtree->create<meta_range_t>("freq/range")
             .set_publisher(boost::bind(&tx_dsp_core_3000::get_freq_range, this))
--- UHD_3.10.1.1_release/lib/usrp/dboard/db_xcvr2450.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/usrp/dboard/db_xcvr2450.cpp	2020-07-08 22:28:53.719238944 +0200
@@ -236,18 +236,18 @@
         .set_publisher(boost::bind(&xcvr2450::get_rssi, this));
     BOOST_FOREACH(const std::string &name, xcvr_rx_gain_ranges.keys()){
         this->get_rx_subtree()->create<double>("gains/"+name+"/value")
-            .set_coercer(boost::bind(&xcvr2450::set_rx_gain, this, _1, name))
+            .set_coercer(boost::bind(&xcvr2450::set_rx_gain, this, boost::placeholders::_1, name))
             .set(xcvr_rx_gain_ranges[name].start());
         this->get_rx_subtree()->create<meta_range_t>("gains/"+name+"/range")
             .set(xcvr_rx_gain_ranges[name]);
     }
     this->get_rx_subtree()->create<double>("freq/value")
-        .set_coercer(boost::bind(&xcvr2450::set_lo_freq, this, _1))
+        .set_coercer(boost::bind(&xcvr2450::set_lo_freq, this, boost::placeholders::_1))
         .set(double(2.45e9));
     this->get_rx_subtree()->create<meta_range_t>("freq/range")
         .set(xcvr_freq_range);
     this->get_rx_subtree()->create<std::string>("antenna/value")
-        .add_coerced_subscriber(boost::bind(&xcvr2450::set_rx_ant, this, _1))
+        .add_coerced_subscriber(boost::bind(&xcvr2450::set_rx_ant, this, boost::placeholders::_1))
         .set(xcvr_antennas.at(0));
     this->get_rx_subtree()->create<std::vector<std::string> >("antenna/options")
         .set(xcvr_antennas);
@@ -258,7 +258,7 @@
     this->get_rx_subtree()->create<bool>("use_lo_offset")
         .set(false);
     this->get_rx_subtree()->create<double>("bandwidth/value")
-        .set_coercer(boost::bind(&xcvr2450::set_rx_bandwidth, this, _1)) //complex bandpass bandwidth 
+        .set_coercer(boost::bind(&xcvr2450::set_rx_bandwidth, this, boost::placeholders::_1)) //complex bandpass bandwidth 
         .set(2.0*_rx_bandwidth); //_rx_bandwidth in lowpass, convert to complex bandpass
     this->get_rx_subtree()->create<meta_range_t>("bandwidth/range")
         .set(xcvr_rx_bandwidth_range);
@@ -272,18 +272,18 @@
         .set_publisher(boost::bind(&xcvr2450::get_locked, this));
     BOOST_FOREACH(const std::string &name, xcvr_tx_gain_ranges.keys()){
         this->get_tx_subtree()->create<double>("gains/"+name+"/value")
-            .set_coercer(boost::bind(&xcvr2450::set_tx_gain, this, _1, name))
+            .set_coercer(boost::bind(&xcvr2450::set_tx_gain, this, boost::placeholders::_1, name))
             .set(xcvr_tx_gain_ranges[name].start());
         this->get_tx_subtree()->create<meta_range_t>("gains/"+name+"/range")
             .set(xcvr_tx_gain_ranges[name]);
     }
     this->get_tx_subtree()->create<double>("freq/value")
-        .set_coercer(boost::bind(&xcvr2450::set_lo_freq, this, _1))
+        .set_coercer(boost::bind(&xcvr2450::set_lo_freq, this, boost::placeholders::_1))
         .set(double(2.45e9));
     this->get_tx_subtree()->create<meta_range_t>("freq/range")
         .set(xcvr_freq_range);
     this->get_tx_subtree()->create<std::string>("antenna/value")
-        .add_coerced_subscriber(boost::bind(&xcvr2450::set_tx_ant, this, _1))
+        .add_coerced_subscriber(boost::bind(&xcvr2450::set_tx_ant, this, boost::placeholders::_1))
         .set(xcvr_antennas.at(1));
     this->get_tx_subtree()->create<std::vector<std::string> >("antenna/options")
         .set(xcvr_antennas);
@@ -294,7 +294,7 @@
     this->get_tx_subtree()->create<bool>("use_lo_offset")
         .set(false);
     this->get_tx_subtree()->create<double>("bandwidth/value")
-        .set_coercer(boost::bind(&xcvr2450::set_tx_bandwidth, this, _1)) //complex bandpass bandwidth
+        .set_coercer(boost::bind(&xcvr2450::set_tx_bandwidth, this, boost::placeholders::_1)) //complex bandpass bandwidth
         .set(2.0*_tx_bandwidth); //_tx_bandwidth in lowpass, convert to complex bandpass
     this->get_tx_subtree()->create<meta_range_t>("bandwidth/range")
         .set(xcvr_tx_bandwidth_range);
--- UHD_3.10.1.1_release/lib/usrp/dboard/db_sbx_common.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/usrp/dboard/db_sbx_common.cpp	2020-07-08 22:29:40.068987846 +0200
@@ -162,17 +162,17 @@
         .set_publisher(boost::bind(&sbx_xcvr::get_locked, this, dboard_iface::UNIT_RX));
     BOOST_FOREACH(const std::string &name, sbx_rx_gain_ranges.keys()){
         this->get_rx_subtree()->create<double>("gains/"+name+"/value")
-            .set_coercer(boost::bind(&sbx_xcvr::set_rx_gain, this, _1, name))
+            .set_coercer(boost::bind(&sbx_xcvr::set_rx_gain, this, boost::placeholders::_1, name))
             .set(sbx_rx_gain_ranges[name].start());
         this->get_rx_subtree()->create<meta_range_t>("gains/"+name+"/range")
             .set(sbx_rx_gain_ranges[name]);
     }
     this->get_rx_subtree()->create<double>("freq/value")
-        .set_coercer(boost::bind(&sbx_xcvr::set_lo_freq, this, dboard_iface::UNIT_RX, _1))
+        .set_coercer(boost::bind(&sbx_xcvr::set_lo_freq, this, dboard_iface::UNIT_RX, boost::placeholders::_1))
         .set((freq_range.start() + freq_range.stop())/2.0);
     this->get_rx_subtree()->create<meta_range_t>("freq/range").set(freq_range);
     this->get_rx_subtree()->create<std::string>("antenna/value")
-        .add_coerced_subscriber(boost::bind(&sbx_xcvr::set_rx_ant, this, _1))
+        .add_coerced_subscriber(boost::bind(&sbx_xcvr::set_rx_ant, this, boost::placeholders::_1))
         .set("RX2");
     this->get_rx_subtree()->create<std::vector<std::string> >("antenna/options")
         .set(sbx_rx_antennas);
@@ -203,17 +203,17 @@
         .set_publisher(boost::bind(&sbx_xcvr::get_locked, this, dboard_iface::UNIT_TX));
     BOOST_FOREACH(const std::string &name, sbx_tx_gain_ranges.keys()){
         this->get_tx_subtree()->create<double>("gains/"+name+"/value")
-            .set_coercer(boost::bind(&sbx_xcvr::set_tx_gain, this, _1, name))
+            .set_coercer(boost::bind(&sbx_xcvr::set_tx_gain, this, boost::placeholders::_1, name))
             .set(sbx_tx_gain_ranges[name].start());
         this->get_tx_subtree()->create<meta_range_t>("gains/"+name+"/range")
             .set(sbx_tx_gain_ranges[name]);
     }
     this->get_tx_subtree()->create<double>("freq/value")
-        .set_coercer(boost::bind(&sbx_xcvr::set_lo_freq, this, dboard_iface::UNIT_TX, _1))
+        .set_coercer(boost::bind(&sbx_xcvr::set_lo_freq, this, dboard_iface::UNIT_TX, boost::placeholders::_1))
         .set((freq_range.start() + freq_range.stop())/2.0);
     this->get_tx_subtree()->create<meta_range_t>("freq/range").set(freq_range);
     this->get_tx_subtree()->create<std::string>("antenna/value")
-        .add_coerced_subscriber(boost::bind(&sbx_xcvr::set_tx_ant, this, _1))
+        .add_coerced_subscriber(boost::bind(&sbx_xcvr::set_tx_ant, this, boost::placeholders::_1))
         .set(sbx_tx_antennas.at(0));
     this->get_tx_subtree()->create<std::vector<std::string> >("antenna/options")
         .set(sbx_tx_antennas);
--- UHD_3.10.1.1_release/lib/usrp/dboard/db_sbx_version3.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/usrp/dboard/db_sbx_version3.cpp	2020-07-08 22:36:13.023525695 +0200
@@ -30,8 +30,8 @@
 sbx_xcvr::sbx_version3::sbx_version3(sbx_xcvr *_self_sbx_xcvr) {
     //register the handle to our base SBX class
     self_base = _self_sbx_xcvr;
-    _txlo = adf435x_iface::make_adf4350(boost::bind(&sbx_xcvr::sbx_version3::write_lo_regs, this, dboard_iface::UNIT_TX, _1));
-    _rxlo = adf435x_iface::make_adf4350(boost::bind(&sbx_xcvr::sbx_version3::write_lo_regs, this, dboard_iface::UNIT_RX, _1));
+    _txlo = adf435x_iface::make_adf4350(boost::bind(&sbx_xcvr::sbx_version3::write_lo_regs, this, dboard_iface::UNIT_TX, boost::placeholders::_1));
+    _rxlo = adf435x_iface::make_adf4350(boost::bind(&sbx_xcvr::sbx_version3::write_lo_regs, this, dboard_iface::UNIT_RX, boost::placeholders::_1));
 }
 
 sbx_xcvr::sbx_version3::~sbx_version3(void){
--- UHD_3.10.1.1_release/lib/usrp/dboard/db_sbx_version4.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/usrp/dboard/db_sbx_version4.cpp	2020-07-09 06:17:05.980383443 +0200
@@ -30,8 +30,8 @@
 sbx_xcvr::sbx_version4::sbx_version4(sbx_xcvr *_self_sbx_xcvr) {
     //register the handle to our base SBX class
     self_base = _self_sbx_xcvr;
-    _txlo = adf435x_iface::make_adf4351(boost::bind(&sbx_xcvr::sbx_version4::write_lo_regs, this, dboard_iface::UNIT_TX, _1));
-    _rxlo = adf435x_iface::make_adf4351(boost::bind(&sbx_xcvr::sbx_version4::write_lo_regs, this, dboard_iface::UNIT_RX, _1));
+    _txlo = adf435x_iface::make_adf4351(boost::bind(&sbx_xcvr::sbx_version4::write_lo_regs, this, dboard_iface::UNIT_TX, boost::placeholders::_1));
+    _rxlo = adf435x_iface::make_adf4351(boost::bind(&sbx_xcvr::sbx_version4::write_lo_regs, this, dboard_iface::UNIT_RX, boost::placeholders::_1));
 }
 
 
--- UHD_3.10.1.1_release/lib/usrp/dboard/db_cbx.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/usrp/dboard/db_cbx.cpp	2020-07-09 06:17:37.116881429 +0200
@@ -29,8 +29,8 @@
 sbx_xcvr::cbx::cbx(sbx_xcvr *_self_sbx_xcvr) {
     //register the handle to our base CBX class
     self_base = _self_sbx_xcvr;
-    _txlo = max287x_iface::make<max2870>(boost::bind(&sbx_xcvr::cbx::write_lo_regs, this, dboard_iface::UNIT_TX, _1));
-    _rxlo = max287x_iface::make<max2870>(boost::bind(&sbx_xcvr::cbx::write_lo_regs, this, dboard_iface::UNIT_RX, _1));
+    _txlo = max287x_iface::make<max2870>(boost::bind(&sbx_xcvr::cbx::write_lo_regs, this, dboard_iface::UNIT_TX, boost::placeholders::_1));
+    _rxlo = max287x_iface::make<max2870>(boost::bind(&sbx_xcvr::cbx::write_lo_regs, this, dboard_iface::UNIT_RX, boost::placeholders::_1));
 }
 
 
--- UHD_3.10.1.1_release/lib/usrp/dboard/db_ubx.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/usrp/dboard/db_ubx.cpp	2020-07-09 06:18:37.829885852 +0200
@@ -365,10 +365,10 @@
         // Initialize LOs
         if (_rev == 0)
         {
-            _txlo1 = max287x_iface::make<max2870>(boost::bind(&ubx_xcvr::write_spi_regs, this, TXLO1, _1));
-            _txlo2 = max287x_iface::make<max2870>(boost::bind(&ubx_xcvr::write_spi_regs, this, TXLO2, _1));
-            _rxlo1 = max287x_iface::make<max2870>(boost::bind(&ubx_xcvr::write_spi_regs, this, RXLO1, _1));
-            _rxlo2 = max287x_iface::make<max2870>(boost::bind(&ubx_xcvr::write_spi_regs, this, RXLO2, _1));
+            _txlo1 = max287x_iface::make<max2870>(boost::bind(&ubx_xcvr::write_spi_regs, this, TXLO1, boost::placeholders::_1));
+            _txlo2 = max287x_iface::make<max2870>(boost::bind(&ubx_xcvr::write_spi_regs, this, TXLO2, boost::placeholders::_1));
+            _rxlo1 = max287x_iface::make<max2870>(boost::bind(&ubx_xcvr::write_spi_regs, this, RXLO1, boost::placeholders::_1));
+            _rxlo2 = max287x_iface::make<max2870>(boost::bind(&ubx_xcvr::write_spi_regs, this, RXLO2, boost::placeholders::_1));
             std::vector<max287x_iface::sptr> los = boost::assign::list_of(_txlo1)(_txlo2)(_rxlo1)(_rxlo2);
             BOOST_FOREACH(max287x_iface::sptr lo, los)
             {
@@ -379,10 +379,10 @@
         }
         else if (_rev == 1 or _rev == 2)
         {
-            _txlo1 = max287x_iface::make<max2871>(boost::bind(&ubx_xcvr::write_spi_regs, this, TXLO1, _1));
-            _txlo2 = max287x_iface::make<max2871>(boost::bind(&ubx_xcvr::write_spi_regs, this, TXLO2, _1));
-            _rxlo1 = max287x_iface::make<max2871>(boost::bind(&ubx_xcvr::write_spi_regs, this, RXLO1, _1));
-            _rxlo2 = max287x_iface::make<max2871>(boost::bind(&ubx_xcvr::write_spi_regs, this, RXLO2, _1));
+            _txlo1 = max287x_iface::make<max2871>(boost::bind(&ubx_xcvr::write_spi_regs, this, TXLO1, boost::placeholders::_1));
+            _txlo2 = max287x_iface::make<max2871>(boost::bind(&ubx_xcvr::write_spi_regs, this, TXLO2, boost::placeholders::_1));
+            _rxlo1 = max287x_iface::make<max2871>(boost::bind(&ubx_xcvr::write_spi_regs, this, RXLO1, boost::placeholders::_1));
+            _rxlo2 = max287x_iface::make<max2871>(boost::bind(&ubx_xcvr::write_spi_regs, this, RXLO2, boost::placeholders::_1));
             std::vector<max287x_iface::sptr> los = boost::assign::list_of(_txlo1)(_txlo2)(_rxlo1)(_rxlo2);
             BOOST_FOREACH(max287x_iface::sptr lo, los)
             {
@@ -409,22 +409,22 @@
         get_rx_subtree()->create<std::vector<std::string> >("power_mode/options")
             .set(ubx_power_modes);
         get_rx_subtree()->create<std::string>("power_mode/value")
-            .add_coerced_subscriber(boost::bind(&ubx_xcvr::set_power_mode, this, _1))
+            .add_coerced_subscriber(boost::bind(&ubx_xcvr::set_power_mode, this, boost::placeholders::_1))
             .set("performance");
         get_rx_subtree()->create<std::vector<std::string> >("xcvr_mode/options")
             .set(ubx_xcvr_modes);
         get_rx_subtree()->create<std::string>("xcvr_mode/value")
-            .add_coerced_subscriber(boost::bind(&ubx_xcvr::set_xcvr_mode, this, _1))
+            .add_coerced_subscriber(boost::bind(&ubx_xcvr::set_xcvr_mode, this, boost::placeholders::_1))
             .set("FDX");
         get_tx_subtree()->create<std::vector<std::string> >("power_mode/options")
             .set(ubx_power_modes);
         get_tx_subtree()->create<std::string>("power_mode/value")
-            .add_coerced_subscriber(boost::bind(&uhd::property<std::string>::set, &get_rx_subtree()->access<std::string>("power_mode/value"), _1))
+            .add_coerced_subscriber(boost::bind(&uhd::property<std::string>::set, &get_rx_subtree()->access<std::string>("power_mode/value"), boost::placeholders::_1))
             .set_publisher(boost::bind(&uhd::property<std::string>::get, &get_rx_subtree()->access<std::string>("power_mode/value")));
         get_tx_subtree()->create<std::vector<std::string> >("xcvr_mode/options")
             .set(ubx_xcvr_modes);
         get_tx_subtree()->create<std::string>("xcvr_mode/value")
-            .add_coerced_subscriber(boost::bind(&uhd::property<std::string>::set, &get_rx_subtree()->access<std::string>("xcvr_mode/value"), _1))
+            .add_coerced_subscriber(boost::bind(&uhd::property<std::string>::set, &get_rx_subtree()->access<std::string>("xcvr_mode/value"), boost::placeholders::_1))
             .set_publisher(boost::bind(&uhd::property<std::string>::get, &get_rx_subtree()->access<std::string>("xcvr_mode/value")));
 
         ////////////////////////////////////////////////////////////////////
@@ -436,18 +436,18 @@
         get_tx_subtree()->create<sensor_value_t>("sensors/lo_locked")
             .set_publisher(boost::bind(&ubx_xcvr::get_locked, this, "TXLO"));
         get_tx_subtree()->create<double>("gains/PGA0/value")
-            .set_coercer(boost::bind(&ubx_xcvr::set_tx_gain, this, _1)).set(0);
+            .set_coercer(boost::bind(&ubx_xcvr::set_tx_gain, this, boost::placeholders::_1)).set(0);
         get_tx_subtree()->create<meta_range_t>("gains/PGA0/range")
             .set(ubx_tx_gain_range);
         get_tx_subtree()->create<double>("freq/value")
-            .set_coercer(boost::bind(&ubx_xcvr::set_tx_freq, this, _1))
+            .set_coercer(boost::bind(&ubx_xcvr::set_tx_freq, this, boost::placeholders::_1))
             .set(ubx_freq_range.start());
         get_tx_subtree()->create<meta_range_t>("freq/range")
             .set(ubx_freq_range);
         get_tx_subtree()->create<std::vector<std::string> >("antenna/options")
             .set(ubx_tx_antennas);
         get_tx_subtree()->create<std::string>("antenna/value")
-            .add_coerced_subscriber(boost::bind(&ubx_xcvr::set_tx_ant, this, _1))
+            .add_coerced_subscriber(boost::bind(&ubx_xcvr::set_tx_ant, this, boost::placeholders::_1))
             .set(ubx_tx_antennas.at(0));
         get_tx_subtree()->create<std::string>("connection")
             .set("QI");
@@ -460,7 +460,7 @@
         get_tx_subtree()->create<meta_range_t>("bandwidth/range")
             .set(freq_range_t(bw, bw));
         get_tx_subtree()->create<int64_t>("sync_delay")
-            .add_coerced_subscriber(boost::bind(&ubx_xcvr::set_sync_delay, this, true, _1))
+            .add_coerced_subscriber(boost::bind(&ubx_xcvr::set_sync_delay, this, true, boost::placeholders::_1))
             .set(-8);
 
         ////////////////////////////////////////////////////////////////////
@@ -472,19 +472,19 @@
         get_rx_subtree()->create<sensor_value_t>("sensors/lo_locked")
             .set_publisher(boost::bind(&ubx_xcvr::get_locked, this, "RXLO"));
         get_rx_subtree()->create<double>("gains/PGA0/value")
-            .set_coercer(boost::bind(&ubx_xcvr::set_rx_gain, this, _1))
+            .set_coercer(boost::bind(&ubx_xcvr::set_rx_gain, this, boost::placeholders::_1))
             .set(0);
         get_rx_subtree()->create<meta_range_t>("gains/PGA0/range")
             .set(ubx_rx_gain_range);
         get_rx_subtree()->create<double>("freq/value")
-            .set_coercer(boost::bind(&ubx_xcvr::set_rx_freq, this, _1))
+            .set_coercer(boost::bind(&ubx_xcvr::set_rx_freq, this, boost::placeholders::_1))
             .set(ubx_freq_range.start());
         get_rx_subtree()->create<meta_range_t>("freq/range")
             .set(ubx_freq_range);
         get_rx_subtree()->create<std::vector<std::string> >("antenna/options")
             .set(ubx_rx_antennas);
         get_rx_subtree()->create<std::string>("antenna/value")
-            .add_coerced_subscriber(boost::bind(&ubx_xcvr::set_rx_ant, this, _1)).set("RX2");
+            .add_coerced_subscriber(boost::bind(&ubx_xcvr::set_rx_ant, this, boost::placeholders::_1)).set("RX2");
         get_rx_subtree()->create<std::string>("connection")
             .set("IQ");
         get_rx_subtree()->create<bool>("enabled")
@@ -496,7 +496,7 @@
         get_rx_subtree()->create<meta_range_t>("bandwidth/range")
             .set(freq_range_t(bw, bw));
         get_rx_subtree()->create<int64_t>("sync_delay")
-            .add_coerced_subscriber(boost::bind(&ubx_xcvr::set_sync_delay, this, false, _1))
+            .add_coerced_subscriber(boost::bind(&ubx_xcvr::set_sync_delay, this, false, boost::placeholders::_1))
             .set(-8);
     }
 
--- UHD_3.10.1.1_release/lib/usrp/dboard/db_dbsrx.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/usrp/dboard/db_dbsrx.cpp	2020-07-09 06:20:21.969321680 +0200
@@ -207,13 +207,13 @@
         .set_publisher(boost::bind(&dbsrx::get_locked, this));
     BOOST_FOREACH(const std::string &name, dbsrx_gain_ranges.keys()){
         this->get_rx_subtree()->create<double>("gains/"+name+"/value")
-            .set_coercer(boost::bind(&dbsrx::set_gain, this, _1, name))
+            .set_coercer(boost::bind(&dbsrx::set_gain, this, boost::placeholders::_1, name))
             .set(dbsrx_gain_ranges[name].start());
         this->get_rx_subtree()->create<meta_range_t>("gains/"+name+"/range")
             .set(dbsrx_gain_ranges[name]);
     }
     this->get_rx_subtree()->create<double>("freq/value")
-        .set_coercer(boost::bind(&dbsrx::set_lo_freq, this, _1));
+        .set_coercer(boost::bind(&dbsrx::set_lo_freq, this, boost::placeholders::_1));
     this->get_rx_subtree()->create<meta_range_t>("freq/range")
         .set(dbsrx_freq_range);
     this->get_rx_subtree()->create<std::string>("antenna/value")
@@ -227,7 +227,7 @@
     this->get_rx_subtree()->create<bool>("use_lo_offset")
         .set(false);
     this->get_rx_subtree()->create<double>("bandwidth/value")
-        .set_coercer(boost::bind(&dbsrx::set_bandwidth, this, _1));
+        .set_coercer(boost::bind(&dbsrx::set_bandwidth, this, boost::placeholders::_1));
     this->get_rx_subtree()->create<meta_range_t>("bandwidth/range")
         .set(dbsrx_bandwidth_range);
 
--- UHD_3.10.1.1_release/lib/usrp/dboard/db_tvrx.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/usrp/dboard/db_tvrx.cpp	2020-07-09 06:21:12.305715651 +0200
@@ -190,12 +190,12 @@
     this->get_rx_subtree()->create<int>("sensors"); //phony property so this dir exists
     BOOST_FOREACH(const std::string &name, get_tvrx_gain_ranges().keys()){
         this->get_rx_subtree()->create<double>("gains/"+name+"/value")
-            .set_coercer(boost::bind(&tvrx::set_gain, this, _1, name));
+            .set_coercer(boost::bind(&tvrx::set_gain, this, boost::placeholders::_1, name));
         this->get_rx_subtree()->create<meta_range_t>("gains/"+name+"/range")
             .set(get_tvrx_gain_ranges()[name]);
     }
     this->get_rx_subtree()->create<double>("freq/value")
-        .set_coercer(boost::bind(&tvrx::set_freq, this, _1));
+        .set_coercer(boost::bind(&tvrx::set_freq, this, boost::placeholders::_1));
     this->get_rx_subtree()->create<meta_range_t>("freq/range")
         .set(tvrx_freq_range);
     this->get_rx_subtree()->create<std::string>("antenna/value")
--- UHD_3.10.1.1_release/lib/usrp/dboard/db_dbsrx2.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/usrp/dboard/db_dbsrx2.cpp	2020-07-09 06:23:43.534896372 +0200
@@ -194,13 +194,13 @@
         .set_publisher(boost::bind(&dbsrx2::get_locked, this));
     BOOST_FOREACH(const std::string &name, dbsrx2_gain_ranges.keys()){
         this->get_rx_subtree()->create<double>("gains/"+name+"/value")
-            .set_coercer(boost::bind(&dbsrx2::set_gain, this, _1, name))
+            .set_coercer(boost::bind(&dbsrx2::set_gain, this, boost::placeholders::_1, name))
             .set(dbsrx2_gain_ranges[name].start());
         this->get_rx_subtree()->create<meta_range_t>("gains/"+name+"/range")
             .set(dbsrx2_gain_ranges[name]);
     }
     this->get_rx_subtree()->create<double>("freq/value")
-        .set_coercer(boost::bind(&dbsrx2::set_lo_freq, this, _1))
+        .set_coercer(boost::bind(&dbsrx2::set_lo_freq, this, boost::placeholders::_1))
         .set(dbsrx2_freq_range.start());
     this->get_rx_subtree()->create<meta_range_t>("freq/range")
         .set(dbsrx2_freq_range);
@@ -218,7 +218,7 @@
     double codec_rate = this->get_iface()->get_codec_rate(dboard_iface::UNIT_RX);
 
     this->get_rx_subtree()->create<double>("bandwidth/value")
-        .set_coercer(boost::bind(&dbsrx2::set_bandwidth, this, _1))
+        .set_coercer(boost::bind(&dbsrx2::set_bandwidth, this, boost::placeholders::_1))
         .set(2.0*(0.8*codec_rate/2.0)); //bandwidth in lowpass, convert to complex bandpass
                                         //default to anti-alias at different codec_rate
     this->get_rx_subtree()->create<meta_range_t>("bandwidth/range")
--- UHD_3.10.1.1_release/lib/usrp/dboard/db_tvrx2.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/usrp/dboard/db_tvrx2.cpp	2020-07-09 06:26:07.947447355 +0200
@@ -964,12 +964,12 @@
         .set_publisher(boost::bind(&tvrx2::get_temp, this));
     BOOST_FOREACH(const std::string &name, tvrx2_gain_ranges.keys()){
         this->get_rx_subtree()->create<double>("gains/"+name+"/value")
-            .set_coercer(boost::bind(&tvrx2::set_gain, this, _1, name));
+            .set_coercer(boost::bind(&tvrx2::set_gain, this, boost::placeholders::_1, name));
         this->get_rx_subtree()->create<meta_range_t>("gains/"+name+"/range")
             .set(tvrx2_gain_ranges[name]);
     }
     this->get_rx_subtree()->create<double>("freq/value")
-        .set_coercer(boost::bind(&tvrx2::set_lo_freq, this, _1));
+        .set_coercer(boost::bind(&tvrx2::set_lo_freq, this, boost::placeholders::_1));
     this->get_rx_subtree()->create<meta_range_t>("freq/range")
         .set(tvrx2_freq_range);
     this->get_rx_subtree()->create<std::string>("antenna/value")
@@ -979,12 +979,12 @@
     this->get_rx_subtree()->create<std::string>("connection")
         .set(tvrx2_sd_name_to_conn[get_subdev_name()]);
     this->get_rx_subtree()->create<bool>("enabled")
-        .set_coercer(boost::bind(&tvrx2::set_enabled, this, _1))
+        .set_coercer(boost::bind(&tvrx2::set_enabled, this, boost::placeholders::_1))
         .set(_enabled);
     this->get_rx_subtree()->create<bool>("use_lo_offset")
         .set(false);
     this->get_rx_subtree()->create<double>("bandwidth/value")
-        .set_coercer(boost::bind(&tvrx2::set_bandwidth, this, _1))
+        .set_coercer(boost::bind(&tvrx2::set_bandwidth, this, boost::placeholders::_1))
         .set(_bandwidth);
     this->get_rx_subtree()->create<meta_range_t>("bandwidth/range")
         .set(tvrx2_bandwidth_range);
--- UHD_3.10.1.1_release/lib/usrp/dboard/twinrx/twinrx_ctrl.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/usrp/dboard/twinrx/twinrx_ctrl.cpp	2020-07-09 06:30:57.462545585 +0200
@@ -51,14 +51,14 @@
         }
         //Initialize synthesizer objects
         _lo1_iface[size_t(CH1)] = adf5355_iface::make(
-                boost::bind(&twinrx_ctrl_impl::_write_lo_spi, this, dboard_iface::UNIT_TX, _1));
+                boost::bind(&twinrx_ctrl_impl::_write_lo_spi, this, dboard_iface::UNIT_TX, boost::placeholders::_1));
         _lo1_iface[size_t(CH2)] = adf5355_iface::make(
-                boost::bind(&twinrx_ctrl_impl::_write_lo_spi, this, dboard_iface::UNIT_TX, _1));
+                boost::bind(&twinrx_ctrl_impl::_write_lo_spi, this, dboard_iface::UNIT_TX, boost::placeholders::_1));
 
         _lo2_iface[size_t(CH1)] = adf435x_iface::make_adf4351(
-                boost::bind(&twinrx_ctrl_impl::_write_lo_spi, this, dboard_iface::UNIT_RX, _1));
+                boost::bind(&twinrx_ctrl_impl::_write_lo_spi, this, dboard_iface::UNIT_RX, boost::placeholders::_1));
         _lo2_iface[size_t(CH2)] = adf435x_iface::make_adf4351(
-                boost::bind(&twinrx_ctrl_impl::_write_lo_spi, this, dboard_iface::UNIT_RX, _1));
+                boost::bind(&twinrx_ctrl_impl::_write_lo_spi, this, dboard_iface::UNIT_RX, boost::placeholders::_1));
 
         // Assert synthesizer chip enables
         _gpio_iface->set_field(twinrx_gpio::FIELD_LO1_CE_CH1, 1);
--- UHD_3.10.1.1_release/lib/usrp/b100/b100_impl.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/usrp/b100/b100_impl.cpp	2020-07-09 06:40:34.302753906 +0200
@@ -279,7 +279,7 @@
     _tree->create<std::string>(mb_path / "name").set("B100");
     _tree->create<std::string>(mb_path / "codename").set("B-Hundo");
     _tree->create<std::string>(mb_path / "load_eeprom")
-        .add_coerced_subscriber(boost::bind(&fx2_ctrl::usrp_load_eeprom, _fx2_ctrl, _1));
+        .add_coerced_subscriber(boost::bind(&fx2_ctrl::usrp_load_eeprom, _fx2_ctrl, boost::placeholders::_1));
 
     ////////////////////////////////////////////////////////////////////
     // setup the mboard eeprom
@@ -287,7 +287,7 @@
     const mboard_eeprom_t mb_eeprom(*_fx2_ctrl, B100_EEPROM_MAP_KEY);
     _tree->create<mboard_eeprom_t>(mb_path / "eeprom")
         .set(mb_eeprom)
-        .add_coerced_subscriber(boost::bind(&b100_impl::set_mb_eeprom, this, _1));
+        .add_coerced_subscriber(boost::bind(&b100_impl::set_mb_eeprom, this, boost::placeholders::_1));
 
     ////////////////////////////////////////////////////////////////////
     // create clock control objects
@@ -295,12 +295,12 @@
     //^^^ clock created up top, just reg props here... ^^^
     _tree->create<double>(mb_path / "tick_rate")
         .set_publisher(boost::bind(&b100_clock_ctrl::get_fpga_clock_rate, _clock_ctrl))
-        .add_coerced_subscriber(boost::bind(&fifo_ctrl_excelsior::set_tick_rate, _fifo_ctrl, _1))
-        .add_coerced_subscriber(boost::bind(&b100_impl::update_tick_rate, this, _1));
+        .add_coerced_subscriber(boost::bind(&fifo_ctrl_excelsior::set_tick_rate, _fifo_ctrl, boost::placeholders::_1))
+        .add_coerced_subscriber(boost::bind(&b100_impl::update_tick_rate, this, boost::placeholders::_1));
 
     //add_coerced_subscriber the command time while we are at it
     _tree->create<time_spec_t>(mb_path / "time/cmd")
-        .add_coerced_subscriber(boost::bind(&fifo_ctrl_excelsior::set_time, _fifo_ctrl, _1));
+        .add_coerced_subscriber(boost::bind(&fifo_ctrl_excelsior::set_time, _fifo_ctrl, boost::placeholders::_1));
 
     ////////////////////////////////////////////////////////////////////
     // create codec control objects
@@ -311,12 +311,12 @@
     _tree->create<std::string>(rx_codec_path / "name").set("ad9522");
     _tree->create<meta_range_t>(rx_codec_path / "gains/pga/range").set(b100_codec_ctrl::rx_pga_gain_range);
     _tree->create<double>(rx_codec_path / "gains/pga/value")
-        .set_coercer(boost::bind(&b100_impl::update_rx_codec_gain, this, _1))
+        .set_coercer(boost::bind(&b100_impl::update_rx_codec_gain, this, boost::placeholders::_1))
         .set(0.0);
     _tree->create<std::string>(tx_codec_path / "name").set("ad9522");
     _tree->create<meta_range_t>(tx_codec_path / "gains/pga/range").set(b100_codec_ctrl::tx_pga_gain_range);
     _tree->create<double>(tx_codec_path / "gains/pga/value")
-        .add_coerced_subscriber(boost::bind(&b100_codec_ctrl::set_tx_pga_gain, _codec_ctrl, _1))
+        .add_coerced_subscriber(boost::bind(&b100_codec_ctrl::set_tx_pga_gain, _codec_ctrl, boost::placeholders::_1))
         .set_publisher(boost::bind(&b100_codec_ctrl::get_tx_pga_gain, _codec_ctrl))
         .set(0.0);
 
@@ -333,27 +333,27 @@
     _tx_fe = tx_frontend_core_200::make(_fifo_ctrl, TOREG(SR_TX_FE));
 
     _tree->create<subdev_spec_t>(mb_path / "rx_subdev_spec")
-        .add_coerced_subscriber(boost::bind(&b100_impl::update_rx_subdev_spec, this, _1));
+        .add_coerced_subscriber(boost::bind(&b100_impl::update_rx_subdev_spec, this, boost::placeholders::_1));
     _tree->create<subdev_spec_t>(mb_path / "tx_subdev_spec")
-        .add_coerced_subscriber(boost::bind(&b100_impl::update_tx_subdev_spec, this, _1));
+        .add_coerced_subscriber(boost::bind(&b100_impl::update_tx_subdev_spec, this, boost::placeholders::_1));
 
     const fs_path rx_fe_path = mb_path / "rx_frontends" / "A";
     const fs_path tx_fe_path = mb_path / "tx_frontends" / "A";
 
     _tree->create<std::complex<double> >(rx_fe_path / "dc_offset" / "value")
-        .set_coercer(boost::bind(&rx_frontend_core_200::set_dc_offset, _rx_fe, _1))
+        .set_coercer(boost::bind(&rx_frontend_core_200::set_dc_offset, _rx_fe, boost::placeholders::_1))
         .set(std::complex<double>(0.0, 0.0));
     _tree->create<bool>(rx_fe_path / "dc_offset" / "enable")
-        .add_coerced_subscriber(boost::bind(&rx_frontend_core_200::set_dc_offset_auto, _rx_fe, _1))
+        .add_coerced_subscriber(boost::bind(&rx_frontend_core_200::set_dc_offset_auto, _rx_fe, boost::placeholders::_1))
         .set(true);
     _tree->create<std::complex<double> >(rx_fe_path / "iq_balance" / "value")
-        .add_coerced_subscriber(boost::bind(&rx_frontend_core_200::set_iq_balance, _rx_fe, _1))
+        .add_coerced_subscriber(boost::bind(&rx_frontend_core_200::set_iq_balance, _rx_fe, boost::placeholders::_1))
         .set(std::complex<double>(0.0, 0.0));
     _tree->create<std::complex<double> >(tx_fe_path / "dc_offset" / "value")
-        .set_coercer(boost::bind(&tx_frontend_core_200::set_dc_offset, _tx_fe, _1))
+        .set_coercer(boost::bind(&tx_frontend_core_200::set_dc_offset, _tx_fe, boost::placeholders::_1))
         .set(std::complex<double>(0.0, 0.0));
     _tree->create<std::complex<double> >(tx_fe_path / "iq_balance" / "value")
-        .add_coerced_subscriber(boost::bind(&tx_frontend_core_200::set_iq_balance, _tx_fe, _1))
+        .add_coerced_subscriber(boost::bind(&tx_frontend_core_200::set_iq_balance, _tx_fe, boost::placeholders::_1))
         .set(std::complex<double>(0.0, 0.0));
 
     ////////////////////////////////////////////////////////////////////
@@ -372,20 +372,20 @@
 
         _rx_dsps[dspno]->set_link_rate(B100_LINK_RATE_BPS);
         _tree->access<double>(mb_path / "tick_rate")
-            .add_coerced_subscriber(boost::bind(&rx_dsp_core_200::set_tick_rate, _rx_dsps[dspno], _1));
+            .add_coerced_subscriber(boost::bind(&rx_dsp_core_200::set_tick_rate, _rx_dsps[dspno], boost::placeholders::_1));
         fs_path rx_dsp_path = mb_path / str(boost::format("rx_dsps/%u") % dspno);
         _tree->create<meta_range_t>(rx_dsp_path / "rate/range")
             .set_publisher(boost::bind(&rx_dsp_core_200::get_host_rates, _rx_dsps[dspno]));
         _tree->create<double>(rx_dsp_path / "rate/value")
             .set(1e6) //some default
-            .set_coercer(boost::bind(&rx_dsp_core_200::set_host_rate, _rx_dsps[dspno], _1))
-            .add_coerced_subscriber(boost::bind(&b100_impl::update_rx_samp_rate, this, dspno, _1));
+            .set_coercer(boost::bind(&rx_dsp_core_200::set_host_rate, _rx_dsps[dspno], boost::placeholders::_1))
+            .add_coerced_subscriber(boost::bind(&b100_impl::update_rx_samp_rate, this, dspno, boost::placeholders::_1));
         _tree->create<double>(rx_dsp_path / "freq/value")
-            .set_coercer(boost::bind(&rx_dsp_core_200::set_freq, _rx_dsps[dspno], _1));
+            .set_coercer(boost::bind(&rx_dsp_core_200::set_freq, _rx_dsps[dspno], boost::placeholders::_1));
         _tree->create<meta_range_t>(rx_dsp_path / "freq/range")
             .set_publisher(boost::bind(&rx_dsp_core_200::get_freq_range, _rx_dsps[dspno]));
         _tree->create<stream_cmd_t>(rx_dsp_path / "stream_cmd")
-            .add_coerced_subscriber(boost::bind(&rx_dsp_core_200::issue_stream_command, _rx_dsps[dspno], _1));
+            .add_coerced_subscriber(boost::bind(&rx_dsp_core_200::issue_stream_command, _rx_dsps[dspno], boost::placeholders::_1));
     }
 
     ////////////////////////////////////////////////////////////////////
@@ -396,15 +396,15 @@
     );
     _tx_dsp->set_link_rate(B100_LINK_RATE_BPS);
     _tree->access<double>(mb_path / "tick_rate")
-        .add_coerced_subscriber(boost::bind(&tx_dsp_core_200::set_tick_rate, _tx_dsp, _1));
+        .add_coerced_subscriber(boost::bind(&tx_dsp_core_200::set_tick_rate, _tx_dsp, boost::placeholders::_1));
     _tree->create<meta_range_t>(mb_path / "tx_dsps/0/rate/range")
         .set_publisher(boost::bind(&tx_dsp_core_200::get_host_rates, _tx_dsp));
     _tree->create<double>(mb_path / "tx_dsps/0/rate/value")
         .set(1e6) //some default
-        .set_coercer(boost::bind(&tx_dsp_core_200::set_host_rate, _tx_dsp, _1))
-        .add_coerced_subscriber(boost::bind(&b100_impl::update_tx_samp_rate, this, 0, _1));
+        .set_coercer(boost::bind(&tx_dsp_core_200::set_host_rate, _tx_dsp, boost::placeholders::_1))
+        .add_coerced_subscriber(boost::bind(&b100_impl::update_tx_samp_rate, this, 0, boost::placeholders::_1));
     _tree->create<double>(mb_path / "tx_dsps/0/freq/value")
-        .set_coercer(boost::bind(&tx_dsp_core_200::set_freq, _tx_dsp, _1));
+        .set_coercer(boost::bind(&tx_dsp_core_200::set_freq, _tx_dsp, boost::placeholders::_1));
     _tree->create<meta_range_t>(mb_path / "tx_dsps/0/freq/range")
         .set_publisher(boost::bind(&tx_dsp_core_200::get_freq_range, _tx_dsp));
 
@@ -420,21 +420,21 @@
         _fifo_ctrl, TOREG(SR_TIME64), time64_rb_bases
     );
     _tree->access<double>(mb_path / "tick_rate")
-        .add_coerced_subscriber(boost::bind(&time64_core_200::set_tick_rate, _time64, _1));
+        .add_coerced_subscriber(boost::bind(&time64_core_200::set_tick_rate, _time64, boost::placeholders::_1));
     _tree->create<time_spec_t>(mb_path / "time/now")
         .set_publisher(boost::bind(&time64_core_200::get_time_now, _time64))
-        .add_coerced_subscriber(boost::bind(&time64_core_200::set_time_now, _time64, _1));
+        .add_coerced_subscriber(boost::bind(&time64_core_200::set_time_now, _time64, boost::placeholders::_1));
     _tree->create<time_spec_t>(mb_path / "time/pps")
         .set_publisher(boost::bind(&time64_core_200::get_time_last_pps, _time64))
-        .add_coerced_subscriber(boost::bind(&time64_core_200::set_time_next_pps, _time64, _1));
+        .add_coerced_subscriber(boost::bind(&time64_core_200::set_time_next_pps, _time64, boost::placeholders::_1));
     //setup time source props
     _tree->create<std::string>(mb_path / "time_source/value")
-        .add_coerced_subscriber(boost::bind(&time64_core_200::set_time_source, _time64, _1));
+        .add_coerced_subscriber(boost::bind(&time64_core_200::set_time_source, _time64, boost::placeholders::_1));
     _tree->create<std::vector<std::string> >(mb_path / "time_source/options")
         .set_publisher(boost::bind(&time64_core_200::get_time_sources, _time64));
     //setup reference source props
     _tree->create<std::string>(mb_path / "clock_source/value")
-        .add_coerced_subscriber(boost::bind(&b100_impl::update_clock_source, this, _1));
+        .add_coerced_subscriber(boost::bind(&b100_impl::update_clock_source, this, boost::placeholders::_1));
     static const std::vector<std::string> clock_sources = boost::assign::list_of("internal")("external")("auto");
     _tree->create<std::vector<std::string> >(mb_path / "clock_source/options").set(clock_sources);
 
@@ -443,7 +443,7 @@
     ////////////////////////////////////////////////////////////////////
     _user = user_settings_core_200::make(_fifo_ctrl, TOREG(SR_USER_REGS));
     _tree->create<user_settings_core_200::user_reg_t>(mb_path / "user/regs")
-        .add_coerced_subscriber(boost::bind(&user_settings_core_200::set_reg, _user, _1));
+        .add_coerced_subscriber(boost::bind(&user_settings_core_200::set_reg, _user, boost::placeholders::_1));
 
     ////////////////////////////////////////////////////////////////////
     // create dboard control objects
@@ -461,13 +461,13 @@
     //create the properties and register subscribers
     _tree->create<dboard_eeprom_t>(mb_path / "dboards/A/rx_eeprom")
         .set(rx_db_eeprom)
-        .add_coerced_subscriber(boost::bind(&b100_impl::set_db_eeprom, this, "rx", _1));
+        .add_coerced_subscriber(boost::bind(&b100_impl::set_db_eeprom, this, "rx", boost::placeholders::_1));
     _tree->create<dboard_eeprom_t>(mb_path / "dboards/A/tx_eeprom")
         .set(tx_db_eeprom)
-        .add_coerced_subscriber(boost::bind(&b100_impl::set_db_eeprom, this, "tx", _1));
+        .add_coerced_subscriber(boost::bind(&b100_impl::set_db_eeprom, this, "tx", boost::placeholders::_1));
     _tree->create<dboard_eeprom_t>(mb_path / "dboards/A/gdb_eeprom")
         .set(gdb_eeprom)
-        .add_coerced_subscriber(boost::bind(&b100_impl::set_db_eeprom, this, "gdb", _1));
+        .add_coerced_subscriber(boost::bind(&b100_impl::set_db_eeprom, this, "gdb", boost::placeholders::_1));
 
     //create a new dboard interface and manager
     _dboard_manager = dboard_manager::make(
@@ -480,12 +480,12 @@
     const fs_path db_tx_fe_path = mb_path / "dboards" / "A" / "tx_frontends";
     BOOST_FOREACH(const std::string &name, _tree->list(db_tx_fe_path)){
         _tree->access<double>(db_tx_fe_path / name / "freq" / "value")
-            .add_coerced_subscriber(boost::bind(&b100_impl::set_tx_fe_corrections, this, _1));
+            .add_coerced_subscriber(boost::bind(&b100_impl::set_tx_fe_corrections, this, boost::placeholders::_1));
     }
     const fs_path db_rx_fe_path = mb_path / "dboards" / "A" / "rx_frontends";
     BOOST_FOREACH(const std::string &name, _tree->list(db_rx_fe_path)){
         _tree->access<double>(db_rx_fe_path / name / "freq" / "value")
-            .add_coerced_subscriber(boost::bind(&b100_impl::set_rx_fe_corrections, this, _1));
+            .add_coerced_subscriber(boost::bind(&b100_impl::set_rx_fe_corrections, this, boost::placeholders::_1));
     }
 
     //initialize io handling
@@ -501,7 +501,7 @@
     this->update_rates();
 
     _tree->access<double>(mb_path / "tick_rate") //now add_coerced_subscriber the clock rate setter
-        .add_coerced_subscriber(boost::bind(&b100_clock_ctrl::set_fpga_clock_rate, _clock_ctrl, _1));
+        .add_coerced_subscriber(boost::bind(&b100_clock_ctrl::set_fpga_clock_rate, _clock_ctrl, boost::placeholders::_1));
 
     //reset cordic rates and their properties to zero
     BOOST_FOREACH(const std::string &name, _tree->list(mb_path / "rx_dsps")){
--- UHD_3.10.1.1_release/lib/usrp/x300/x300_radio_ctrl_impl.cpp.orig	2017-01-27 22:22:55.000000000 +0100
+++ UHD_3.10.1.1_release/lib/usrp/x300/x300_radio_ctrl_impl.cpp	2020-07-09 06:44:45.064728745 +0200
@@ -85,7 +85,7 @@
         BOOST_FOREACH(const gpio_atr::gpio_attr_map_t::value_type attr, gpio_atr::gpio_attr_map) {
             _tree->create<uint32_t>(fs_path("gpio") / "FP0" / attr.second)
                 .set(0)
-                .add_coerced_subscriber(boost::bind(&gpio_atr::gpio_atr_3000::set_gpio_attr, _fp_gpio, attr.first, _1));
+                .add_coerced_subscriber(boost::bind(&gpio_atr::gpio_atr_3000::set_gpio_attr, _fp_gpio, attr.first, boost::placeholders::_1));
         }
         _tree->create<uint32_t>(fs_path("gpio") / "FP0" / "READBACK")
             .set_publisher(boost::bind(&gpio_atr::gpio_atr_3000::read_gpio, _fp_gpio));
@@ -101,7 +101,7 @@
 
     _tree->create<meta_range_t>("rx_codecs" / _radio_slot / "gains" / "digital" / "range").set(meta_range_t(0, 6.0, 0.5));
     _tree->create<double>("rx_codecs" / _radio_slot / "gains" / "digital" / "value")
-        .add_coerced_subscriber(boost::bind(&x300_adc_ctrl::set_gain, _adc, _1)).set(0)
+        .add_coerced_subscriber(boost::bind(&x300_adc_ctrl::set_gain, _adc, boost::placeholders::_1)).set(0)
     ;
 
     ////////////////////////////////////////////////////////////////
@@ -128,7 +128,7 @@
 
         if (_tree->exists(fs_path("time") / "cmd")) {
             _tree->access<time_spec_t>(fs_path("time") / "cmd")
-                .add_coerced_subscriber(boost::bind(&x300_radio_ctrl_impl::set_fe_cmd_time, this, _1, i));
+                .add_coerced_subscriber(boost::bind(&x300_radio_ctrl_impl::set_fe_cmd_time, this, boost::placeholders::_1, i));
         }
     }
 
@@ -352,7 +352,7 @@
         _tree->create<dboard_eeprom_t>(db_path / EEPROM_PATHS[i])
             .set(_db_eeproms[addr])
             .add_coerced_subscriber(boost::bind(&x300_radio_ctrl_impl::_set_db_eeprom,
-                this, zpu_i2c, (BASE_ADDR | addr), _1));
+                this, zpu_i2c, (BASE_ADDR | addr), boost::placeholders::_1));
     }
 
     //create a new dboard interface
@@ -414,7 +414,7 @@
             if (_tree->exists(db_path / "rx_frontends" / _rx_fe_map[i].db_fe_name / "antenna" / "value")) {
                 // We need a desired subscriber for antenna/value because the experts don't coerce that property.
                 _tree->access<std::string>(db_path / "rx_frontends" / _rx_fe_map[i].db_fe_name / "antenna" / "value")
-                    .add_desired_subscriber(boost::bind(&x300_radio_ctrl_impl::_update_atr_leds, this, _1, i));
+                    .add_desired_subscriber(boost::bind(&x300_radio_ctrl_impl::_update_atr_leds, this, boost::placeholders::_1, i));
             }
             _update_atr_leds("", i); //init anyway, even if never called
         }
@@ -427,7 +427,7 @@
             if (_tree->exists(db_tx_fe_path / _tx_fe_map[i].db_fe_name / "freq" / "value")) {
                 _tree->access<double>(db_tx_fe_path / _tx_fe_map[i].db_fe_name / "freq" / "value")
                         .add_coerced_subscriber(boost::bind(&x300_radio_ctrl_impl::set_tx_fe_corrections, this, db_path,
-                                                            _root_path / "tx_fe_corrections" / _tx_fe_map[i].db_fe_name, _1));
+                                                            _root_path / "tx_fe_corrections" / _tx_fe_map[i].db_fe_name, boost::placeholders::_1));
             }
         }
     }
@@ -438,7 +438,7 @@
                 _tree->access<double>(db_rx_fe_path / _tx_fe_map[i].db_fe_name / "freq" / "value")
                         .add_coerced_subscriber(boost::bind(&x300_radio_ctrl_impl::set_rx_fe_corrections, this, db_path,
                                                             _root_path / "rx_fe_corrections" / _tx_fe_map[i].db_fe_name,
-                                                            _1));
+                                                            boost::placeholders::_1));
             }
         }
     }
--- UHD_3.10.1.1_release/lib/usrp/x300/x300_impl.cpp.orig	2017-01-27 22:22:55.000000000 +0100
+++ UHD_3.10.1.1_release/lib/usrp/x300/x300_impl.cpp	2020-07-09 06:47:51.430385783 +0200
@@ -1422,7 +1422,7 @@
 
 bool x300_impl::wait_for_clk_locked(mboard_members_t& mb, uint32_t which, double timeout)
 {
-    boost::system_time timeout_time = boost::get_system_time() + boost::posix_time::milliseconds(timeout * 1000.0);
+    boost::system_time timeout_time = boost::get_system_time() + boost::posix_time::milliseconds(static_cast<int64_t>(timeout * 1000.0));
     do {
         if (mb.fw_regmap->clock_status_reg.read(which)==1)
             return true;
--- UHD_3.10.1.1_release/lib/usrp_clock/octoclock/octoclock_impl.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/usrp_clock/octoclock/octoclock_impl.cpp	2020-07-09 06:54:58.391406069 +0200
@@ -243,7 +243,7 @@
         _oc_dict[oc].eeprom = octoclock_eeprom_t(_oc_dict[oc].ctrl_xport, _proto_ver);
         _tree->create<octoclock_eeprom_t>(oc_path / "eeprom")
             .set(_oc_dict[oc].eeprom)
-            .add_coerced_subscriber(boost::bind(&octoclock_impl::_set_eeprom, this, oc, _1));
+            .add_coerced_subscriber(boost::bind(&octoclock_impl::_set_eeprom, this, oc, boost::placeholders::_1));
 
         ////////////////////////////////////////////////////////////////////
         // Initialize non-GPSDO sensors
--- UHD_3.10.1.1_release/lib/transport/udp_zero_copy.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/transport/udp_zero_copy.cpp	2020-07-09 16:41:02.940903362 +0200
@@ -190,7 +190,7 @@
         _socket = socket_sptr(new asio::ip::udp::socket(_io_service));
         _socket->open(asio::ip::udp::v4());
         _socket->connect(receiver_endpoint);
-        _sock_fd = _socket->native();
+        _sock_fd = _socket->native_handle();
 
         //allocate re-usable managed receive buffers
         for (size_t i = 0; i < get_num_recv_frames(); i++){
--- UHD_3.10.1.1_release/lib/transport/gen_vrt_if_packet.py.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/transport/gen_vrt_if_packet.py	2020-07-09 17:18:08.118848539 +0200
@@ -33,11 +33,11 @@
 #include <uhd/exception.hpp>
 #include <uhd/transport/vrt_if_packet.hpp>
 #include <uhd/utils/byteswap.hpp>
-#include <boost/detail/endian.hpp>
+#include <boost/predef/other/endian.h>
 #include <vector>
 
 //define the endian macros to convert integers
-#ifdef BOOST_BIG_ENDIAN
+#if BOOST_ENDIAN_BIG_BYTE
     #define BE_MACRO(x) (x)
     #define LE_MACRO(x) uhd::byteswap(x)
 #else
--- UHD_3.10.1.1_release/lib/transport/tcp_zero_copy.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/transport/tcp_zero_copy.cpp	2020-07-09 16:47:09.155586073 +0200
@@ -154,7 +154,7 @@
         //create, open, and connect the socket
         _socket.reset(new asio::ip::tcp::socket(_io_service));
         _socket->connect(receiver_endpoint);
-        _sock_fd = _socket->native();
+        _sock_fd = _socket->native_handle();
 
         //packets go out ASAP
         asio::ip::tcp::no_delay option(true);
--- UHD_3.10.1.1_release/lib/transport/udp_simple.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/lib/transport/udp_simple.cpp	2020-07-09 17:50:29.444998139 +0200
@@ -56,7 +56,7 @@
     }
 
     size_t recv(const asio::mutable_buffer &buff, double timeout){
-        if (not wait_for_recv_ready(_socket->native(), timeout)) return 0;
+        if (not wait_for_recv_ready(_socket->native_handle(), timeout)) return 0;
         return _socket->receive_from(asio::buffer(buff), _recv_endpoint);
     }
 
--- UHD_3.10.1.1_release/examples/rx_samples_to_file.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/examples/rx_samples_to_file.cpp	2020-07-09 18:39:59.402241834 +0200
@@ -178,7 +178,7 @@
 
     while (true) {
         if ((not first_lock_time.is_not_a_date_time()) and
-                (boost::get_system_time() > (first_lock_time + boost::posix_time::seconds(setup_time))))
+                (boost::get_system_time() > (first_lock_time + boost::posix_time::seconds(static_cast<int64_t>(setup_time)))))
         {
             std::cout << " locked." << std::endl;
             break;
@@ -192,7 +192,7 @@
         else {
             first_lock_time = boost::system_time();	//reset to 'not a date time'
 
-            if (boost::get_system_time() > (start + boost::posix_time::seconds(setup_time))){
+            if (boost::get_system_time() > (start + boost::posix_time::seconds(static_cast<int64_t>(setup_time)))){
                 std::cout << std::endl;
                 throw std::runtime_error(str(boost::format("timed out waiting for consecutive locks on sensor \"%s\"") % sensor_name));
             }
@@ -312,15 +312,15 @@
     //set the antenna
     if (vm.count("ant")) usrp->set_rx_antenna(ant);
 
-    boost::this_thread::sleep(boost::posix_time::seconds(setup_time)); //allow for some setup time
+    boost::this_thread::sleep(boost::posix_time::seconds(static_cast<int64_t>(setup_time))); //allow for some setup time
 
     //check Ref and LO Lock detect
     if (not vm.count("skip-lo")){
-        check_locked_sensor(usrp->get_rx_sensor_names(0), "lo_locked", boost::bind(&uhd::usrp::multi_usrp::get_rx_sensor, usrp, _1, 0), setup_time);
+        check_locked_sensor(usrp->get_rx_sensor_names(0), "lo_locked", boost::bind(&uhd::usrp::multi_usrp::get_rx_sensor, usrp, boost::placeholders::_1, 0), setup_time);
         if (ref == "mimo")
-            check_locked_sensor(usrp->get_mboard_sensor_names(0), "mimo_locked", boost::bind(&uhd::usrp::multi_usrp::get_mboard_sensor, usrp, _1, 0), setup_time);
+            check_locked_sensor(usrp->get_mboard_sensor_names(0), "mimo_locked", boost::bind(&uhd::usrp::multi_usrp::get_mboard_sensor, usrp, boost::placeholders::_1, 0), setup_time);
         if (ref == "external")
-            check_locked_sensor(usrp->get_mboard_sensor_names(0), "ref_locked", boost::bind(&uhd::usrp::multi_usrp::get_mboard_sensor, usrp, _1, 0), setup_time);
+            check_locked_sensor(usrp->get_mboard_sensor_names(0), "ref_locked", boost::bind(&uhd::usrp::multi_usrp::get_mboard_sensor, usrp, boost::placeholders::_1, 0), setup_time);
     }
 
     if (total_num_samps == 0){
--- UHD_3.10.1.1_release/examples/benchmark_rate.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/examples/benchmark_rate.cpp	2020-07-09 18:42:41.548030081 +0200
@@ -31,7 +31,7 @@
 
 namespace po = boost::program_options;
 
-const double CLOCK_TIMEOUT = 1000;  // 1000mS timeout for external clock locking
+const int CLOCK_TIMEOUT = 1000;  // 1000mS timeout for external clock locking
 const double INIT_DELAY    = 0.05;  // 50mS initial delay before transmit
 //typedef boost::atomic<bool>   atomic_bool;
 // We'll fake atomic bools for now, for more backward compat.
@@ -471,7 +471,7 @@
     const long usecs = long((duration - secs)*1e6);
     boost::this_thread::sleep(boost::posix_time::seconds(secs)
             + boost::posix_time::microseconds(usecs)
-            + boost::posix_time::milliseconds( (rx_channel_nums.size() <= 1 and tx_channel_nums.size() <= 1) ? 0 : (INIT_DELAY * 1000))
+            + boost::posix_time::milliseconds( (rx_channel_nums.size() <= 1 and tx_channel_nums.size() <= 1) ? 0 : static_cast<int64_t>(INIT_DELAY * 1000))
     );
 
     //interrupt and join the threads
--- UHD_3.10.1.1_release/examples/network_relay.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/examples/network_relay.cpp	2020-07-09 18:47:38.346422186 +0200
@@ -127,7 +127,7 @@
         wait_for_thread.notify_one();    // notify constructor that this thread has started
         std::vector<char> buff(insane_mtu);
         while (not boost::this_thread::interruption_requested()){
-            if (wait_for_recv_ready(_server_socket->native())){
+            if (wait_for_recv_ready(_server_socket->native_handle())){
                 boost::mutex::scoped_lock lock(_endpoint_mutex);
                 const size_t len = _server_socket->receive_from(asio::buffer(&buff.front(), buff.size()), _endpoint);
                 lock.unlock();
@@ -153,7 +153,7 @@
         wait_for_thread.notify_one();    // notify constructor that this thread has started
         std::vector<char> buff(insane_mtu);
         while (not boost::this_thread::interruption_requested()){
-            if (wait_for_recv_ready(_client_socket->native())){
+            if (wait_for_recv_ready(_client_socket->native_handle())){
                 const size_t len = _client_socket->receive(asio::buffer(&buff.front(), buff.size()));
                 boost::mutex::scoped_lock lock(_endpoint_mutex);
                 _server_socket->send_to(asio::buffer(&buff.front(), len), _endpoint);
--- UHD_3.10.1.1_release/examples/tx_samples_from_file.cpp.orig	2017-01-18 19:00:32.000000000 +0100
+++ UHD_3.10.1.1_release/examples/tx_samples_from_file.cpp	2020-07-09 18:49:11.789249296 +0200
@@ -193,7 +193,7 @@
         else if (type == "short") send_from_file<std::complex<short> >(usrp, "sc16", wirefmt, file, spb);
         else throw std::runtime_error("Unknown type " + type);
 
-        if(repeat and delay != 0.0) boost::this_thread::sleep(boost::posix_time::milliseconds(delay));
+        if(repeat and delay != 0.0) boost::this_thread::sleep(boost::posix_time::milliseconds(static_cast<int64_t>(delay)));
     } while(repeat and not stop_signal_called);
 
     //finished
